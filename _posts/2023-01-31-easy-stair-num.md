---
title: 백준 10844번_ DP - 실버1 - 쉬운 계단 수
categories: [Computer science, Algorithm]
tags: [실버1, baekjoon online judge, dynamic programming, 10844번, 쉬운 계단 수, DP, 알고리즘, 코딩 테스트, 백준]
---

**!본 포스팅은 백준 코딩테스트 10844번 - [쉬운 계단 수](https://www.acmicpc.net/problem/10844) 풀이입니다.**

## 처음으로 맞춘 풀이
``` cpp
#include <iostream>
using namespace std;

int arr[101][10] = {0,};

void calc(int n) {
    for(int i=2; i<=n; i++) {
        for(int j=0; j<=9; j++) {
            if(j==0) {
                arr[i][0] = arr[i-1][1] % 1000000000;
            } else if(j==9) {
                arr[i][9] = arr[i-1][8] % 1000000000;
            } else {
                arr[i][j] = (arr[i-1][j-1] + arr[i-1][j+1]) % 1000000000;
            }
        }
    }
}

int main(void) {
    int n=0;
    int sum = 0;
    
    for(int i=1; i<=9; i++) {
        arr[1][i] = 1; 
    }
    
    cin >> n;
    
    calc(n);
    
    for(int j=0;j<=9; j++) {
        sum += arr[n][j];
        sum %= 1000000000;
    }
    
    cout << sum;
    
    return 0;
}
```

이 문제는 앞선 알고리즘 포스팅에서 풀었던 방식과 동일한 유형의 Dynamic Programming 문제입니다. 처음에는 일반화된 점화식을 구해서 문제를 풀이하려고 했는데 N=4까지는 "2*(n-1)-n"과 같은 일반화된 식이 도출되지만 그 이후부터는 기하급수적으로 늘고 하나의 일반화된 식으로 표현하기는 불가능해보였습니다. 그 후 풀이를 찾아보다가 2차원 배열을 활용한 풀이를 보았고 해당 풀이를 참고하여 작성한 코드입니다. 우선 행에는 N(숫자의 길이)를 매핑하고 열의 인덱스는 끝자리 수를 의미합니다. 즉 예를들어 5행 3열의 값은 N=5이면서 끝자리가 3인 수의 총 개수를 담고 있는 배열입니다. 이 문제를 이렇게 풀이할 수 있는 이유는 N=1부터 N=3정도 까지 모든 경우의 수를 써보면 결국 다음 N의 숫자의 개수는 현재 N의 끝자리 수가 **0 혹은 9 중에 하나인지, 아닌지**에 따라 케이스가 나뉜다는 것을 알 수 있습니다. 이를 바탕으로 위 코드를 보면 쉽게 이해하실 수 있을 것입니다. 그것보다 DP 문제나 구해야 하는 결과값이 매우 커지는 알고리즘 문제의 경우 엄청 큰수로 나눈 나머지를 구하는 문제가 많이 나오는데, 이때 모듈러 연산(나머지 연산)의 분배법칙에 대해 이해하고 있어야 합니다. 값이 커지는 즉시 모듈러 연산을 해줘야 오버플로우가 발생하지 않기 때문에 값이 커지는 그때그때마다 모듈러 연산의 분배법칙을 활용해 값의 크기를 줄여줘야 합니다. 

## 모듈러 연산(나머지 연산)의 분배법칙이란?
> 모듈러 연산이란 나머지 연산을 의미합니다. 앞서 말씀드린 것처럼 알고리즘 문제에서 값이 너무 커지면 오버플로우가 발생하게 되는데 이를 방지하기 위해 문제에서 임의의 큰 수로 나눈 나머지를 구하라는 문제가 많습니다. 이때 값이 매우 커지면 +,* 등의 연산을 할 때마다 즉시 나머지 연산을 해줘야하는데 이것은 모듈러 연산이 분배법칙이 적용되는지 유무에 따라 오류가 되기도하고 정답이 되기도 합니다. 모듈러 연산에서 말하는 분배법칙이란 다음과 같습니다. 
```
(A + B) % N = ((A % N) + (B % N)) % N
```
위 법칙이 성립함을 증명하는 과정은 아래와 같습니다.
```
A = q1 X N + r1 
B = q2 X N + r2
```
A,B를 N으로 나눴을 때 몫과 나머지를 각각 q1,r1과 q2,r2라고 합시다. 이를 첫번째 식에 적용하면
```
(q1 X N + r1 + q2 X N + r2)  
```
위 식을 아래와 같이 치환할 수 있습니다.
```
((q1+q2) X N + r1 + r2) % N
```
이때 모듈러는 나머지 연산이므로 결국 위 식의 나머지는 아래와 같습니다.
```
(r1+r2)%N
```
여기서 A,B를 N으로 나눈 나머지가 각각 r1,r2이므로 
``` 
r1 = A % N
r2 = B % N
```
이를 통해 아래 식이 성립함을 증명할 수 있습니다.
```
(A + B) % N = ((A % N) + (B % N)) % N
```
현재 위 증명 과정은 "+"로 묶여 있는 변수들간에 모듈러 분배법칙이 적용되는 것을 증명한 것인데, 이 외에도 "-"와 "*"에도 분배법칙이 적용 가능하지만 "/" 나누기 연산에는 성립하지 않습니다.
또한, "-" 연산의 경우 "-" 연산을 하다가 음수가 되지 않도록 경계하여 조정해줘야 하는데 이때 "-" 연산을 하다가 0에 가까워져 음수가 될 것 같으면 나누는 값을 한번 더해줘서 음수가 되지 않게 처리해주면 됩니다.  

## 다른 사람의 풀이1
``` cpp
#include <iostream>
#include <vector>

#define mod 1000000000
using namespace std;

int dp[101][10] = {
    0,
};
int main()
{
    int n;
    cin >> n;

    for (int i = 1; i < 10; i++) {
        dp[1][i] = 1;
    }

    for (int i = 2; i <= n; i++) {
        for (int j = 0; j < 10; j++) {
            if (j == 0)
                dp[i][0] = dp[i - 1][j + 1];
            else if (j == 9)
                dp[i][9] = dp[i - 1][j - 1];
            else
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];

            dp[i][j] %= mod;
        }
    }

    int result = 0;
    for (int i = 0; i < 10; i++) {
        result = (result + dp[n][i]) % mod;
    }
    cout << result << "\n";

    return 0;
}
```
다른 사람이 푼 풀이 역시 제 풀이와 로직이 모두 동일하여 부가적인 설명은 생략하도록 하겠습니다. 

## 최적화한 나의 풀이
최적화한 풀이가 다른 사람이 푼 풀이와 동일하여서 이하 설명은 생략하도록 하겠습니다.

## References
> https://velog.io/@sw801733/%EB%82%98%EB%A8%B8%EC%A7%80-%EC%97%B0%EC%82%B0-%EB%B6%84%EB%B0%B0%EB%B2%95%EC%B9%99-%EB%AA%A8%EB%93%88%EB%9F%AC-%EC%97%B0%EC%82%B0