---
title: 오브젝트(조영호 저)_ 객체, 설계 
categories: [Computer science, Object Oriented Programming]
tags: [Object Oriented Programming, object, study, OOP, 객체 지향 프로그래밍, 객체, 스터디]
---

조영호 님의 **오브젝트: 코드로 이해하는 객체지향 설계**라는 책으로 객체 지향 프로그래밍과 관련된 스터디를 진행하며 공부한 내용을 정리하고 공유하고자 합니다. 각 포스팅은 챕터 별로 업로드될 예정이며, 모든 내용을 담기보다는 개인적으로 중요하다고 생각되는 내용 위주로 요약하여 작성할 예정입니다.

## 객체 지향 패러다임
현대 사회의 패러다임의 정의는 **한 시대의 사회 전체가 공유하는 이론이나 방법, 문제 의식 등의 체계** 정도로 표현할 수 있으며 프로그래밍에 있어서 패러다임은 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지하고 프로그래밍 패러다임을 교육시킴으로써 동일한 규칙과 방법을 공유하는 개발자로 성장할 수 있게 도와줍니다. 조영호 님이 책에서 말씀하신 것처럼 
프로그래밍 패러다임 중 하나인 객체 지향 패러다임을 통해 개발자들이 동일한 규칙과 표준에 따라 프로그램을 작성할 수 있게 도움을 주고 어느 정도 유사한 그림을 머릿속에 그릴 수 있는 기반을 제공할 수 있습니다.

## 이론? 실무?
로버트 L. 글래스(Robert L. Glass)는 《소프트웨어 크리에이티비티 2.0》에서 "이론 대 실무"라는 주제에 대해 어떤 분야를 막론하고 이론을 정립할 수 없는 초기에는 실무가 먼저 급속한 발전을 이룬다고 말하고 있습니다. 즉, 어떤 분야든 초기 단계에서는 아무것도 없는 상태에서 이론을 정립하기보다는 실무를 관찰한 결과를 바탕으로 이론을 정립하는 것이 최선의 방법이다라고 말하고 있는 것입니다. 이를 통해 역사가 그렇게 오래되지 않은 소프트웨어 분야는 아직 걸음마 단계에 머물러 있기 때문에 이론보다 실무가 더 앞서 있고 그렇기 때문에 실무가 더 중요하다고 말하고 있습니다.   
**제 개인적인 생각으로는 소프트웨어 분야에 있어서는 이론보다 실무가 더 앞서 있다고 동의하지만 글래스가 말했던 것처럼 분야와 무관하게 모든 분야의 초기 단계에서 이론보다 실무가 앞선다는 말은 다소 과도한 일반화가 아닌가라는 생각이 들었습니다. 이론을 바탕으로 시작된 분야도 충분히 존재하고 그말인 즉슨 해당 분야가 초기 단계에 머물러있더라도 이론이 실무를 추월하는 경우가 발생할 수 있기 때문입니다.**

## 모듈이란?
로버트 마틴(Robert C. Martin)은 《클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법》에서 모듈이 가져야하는 세 가지 기능에 관해서 설명합니다. 여기서 모듈이란 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미합니다. 마틴에 따르면 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 합니다. 오브젝트의 저자 조영호 님은 티켓 판매 애플리케이션의 예시를 들며 이러한 모듈의 조건에 대해 설명하고 있습니다.   
티켓 판매 애플리케이션 내 Theater 클래스의 메인 비즈니스 로직인 enter 메서드의 흐름을 살펴보면 아래와 같습니다.
```
소극장은 관람객의 가방을 열어 그 안에 초대장이 들어 있는지 살펴본다.
가방 안에 초대장이 들어 있으면 판매원은 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.
가방 안에 초대장이 들어 있지 않다면 관람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립한 후
매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.
```
위 흐름에서의 가장 큰 문제는 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점입니다. 이러한 부분을 해당 코드를 처음 읽는 개발자로 하여금 이해하기 어렵게 만들고 예상을 벗어난 코드라고 말할 수 있습니다. 로버트 마틴이 말하는 이해하기 쉬운 코드란, 우리의 상식과 같아야하고 예상을 벗어나지 않는 코드를 말합니다. 하지만 실생활에서 소극장이라는 객체가 관람객의 가방을 열어 티켓을 넣어준다던지, 판매원의 역할 대행처럼 티켓을 관리하고 현금을 관리하며 손님의 가방에 티켓을 넣어주는 행동은 일어날 수 없으며 매우 부자연스럽습니다.   
이 외에도 위 흐름을 이해하기 어렵게 만드는 이유로 이 코드를 이해하기 위해서 여러가지 세부적인 내용들을 한꺼번에 기억하고 있어야 된다는 점을 들 수 있습니다. 책에 작성된 코드를 보면 enter 메서드를 실행하기 위해서 너무나도 많은 세부적인 메서드들이 유기적으로 호출되며 연결되어 있습니다. 이렇게 복잡하게 얽힌 관계들이 해당 코드를 처음보는 개발자들에게 더욱 이해하기 어렵게 만들 수 있습니다.   
그리고 단순히 이해를 어렵게 만드는 것 뿐만 아니라 서로 유기적으로 연결되어 있다는 건 객체 간 의존성이 높다는 것을 의미하며 이는 어떤 객체가 변경될 때 관계가 있는 다른 객체도 변경되어야만 할 수도 있음을 내포하고 있습니다. 하지만 그렇다고 해서 객체 간 의존성을 모두 없애는 것이 정답은 아닙니다. 객체 지향 설계 자체가 객체간 서로 의존하고 협력하는 객체들의 공동체를 구성하는 것이기 때문에 최소한의 의존성은 남겨둔 채 불필요한 의존성을 제거하는 것에 주안점을 둬야합니다.   
이러한 의존성의 개념은 결합도(coupling)으로 표현하기도 하는데 의존성이 높은 경우 결합도가 높다고 말하며 의존성이 합리적인 경우 결합도가 낮다고 표현합니다.

## 객체 간 의존성을 낮추는 방법
위에 Theater 클래스의 enter 메서드의 문제점인 의존성이 높은 이유는 Theater라는 객체가 관람객, 판매원 객체에 대해 너무 많은 정보를 알고 통제한다는 점에 있습니다. 이를 해결하기 위해서는 각 객체의 자율성을 높여주면 됩니다. 이를 위한 가장 기본적인 방법으로는 객체를 인터페이스 영역과 구현 영역으로 나누고 외부 객체에게는 인터페이스만을 공개하고 활용하게 만들어 객체 사이의 결합도를 낮출 수 있습니다. 이런 식으로 인터페이스 영역과 구현 영역을 나누어 내부 구현 부분을 외부에게 노출하지 않는 것을 캡슐화라고 합니다. 여기서 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것입니다. 객체의 응집도를 높이기 위해서는 객체 스스로가 자신의 데이터를 책임지는 자율적인 존재여야 합니다. 또한 외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 방법입니다.

## 절차 지향과 객체 지향
위 Theater 예제를 정리해보면 Theater의 enter 메서드 안에서 Audience와 TicketSeller로부터 Bag 과 TicketOffice를 가져와 관람객을 입장시키는 절차를 나타내고 있습니다. 이 관점에서 Theater의 enter 메서드는 프로세스(Process)이며 Audience, TicketSeller, Bag, TicketOffice는 데이터(Data)입니다. 본 책에서는 이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차 지향 프로그래밍(Procedural Programming)이라고 설명하고 있습니다. 이와 반대로 프로세스와 데이터를 동일한 모듈 내부에 위치시키는 것은 객체 지향 프로그래밍(Object-Oriented Programming)이라고 합니다.
처음에 책을 읽으며 한 가지 의문점이 들었던 부분으로, **그러면 객체 지향적으로 의존성을 줄인 코드에서도 Audience가 Bag에 대한 Buy()메서드를 가지고 처리하는데 이것 역시 절차 지향적 프로그래밍이 아닌가? 라는 생각을 했었습니다. 이에 대한 정확한 정답을 찾을 순 없지만 제가 생각하기에는 Audience가 구현한 Buy()라는 메서드 로직을 굳이 Audienece가 가지고 있지 않고 Bag이 가지고 있는 것이 더욱 객체 지향적이지 않나라는 생각이 들었습니다.** 하지만 이렇게 하면 가방이라는 사물 자체가 자신(가방) 안에 든 물건을 직접 관리한다는 의미로 바뀌어 앞서 로버트 마틴이 말했던 모듈의 3가지 조건 중 다른 사람이 이해하기 쉬운 코드라는 조건을 충족시키기에는 다소 부자연스러운 면이 있어보이기도 합니다.   
**이러한 고민을 통해 제가 느낀 점은 현실 인간의 사고를 거스르면서까지 더욱 객체의 책임을 강화하는 방식으로 코딩을 할 수도 있고 조금 더 인간의 사고 흐름적으로 구현하며 조금은 객체의 책임을 유연하게 가져가는 방식도 있을 것 같다는 점입니다. 즉, 이에 대한 선택은 설계자 혹은 해당 코드를 작성하는 프로그래머의 몫이며 trade-off적인 상황이지 않을까라고 생각합니다.**   
때마침 이에대한 고민에 답을하듯 1챕터 후반부에서 이에대해 설명하고 있습니다. 이 책의 저자는 **어떤 기능을 설계하는 방법은 한가지 이상일 수 있으며, 그렇기 때문에 설계는 trade-off의 산물이다.**라고 말하고 있습니다. 또한, 앞서 제가 고민했던 것과 같이 Bag, TicketOffice, Teater 등도 스스로 행동하고 자기 자신을 책임지는 자율적인 존재로 수정하며 비교하고 있는데 이는 무생물을 스스로 행동할 수 있는 객체로 표현한 것입니다. 이렇게 비록 현실에서는 수동적인 존재라고 하더라도 객체 지향 세계에서는 이들이 모두 능동적이고 자율적인 존재로 바뀌게 되는데 레베카 워프스브록(Rebecca Wirfs-Brock)은 이처럼 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인화(anthropomorphism)라고 부릅니다.

## 좋은 설계란?
좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계입니다. 변경을 수용할 수 있는 설계가 중요한 이유는 요구사항은 자주 변경되기 때문입니다. 또한 개발을 시작하는 시점에 모든 요구사항을 수집하는 것은 불가능하기 때문입니다. 혹여나 개발 시작 시점에 모든 요구사항을 수집할 수 있다고 하더라도 개발을 진행하는 과정에서 요구사항은 바뀔 수 밖에 없습니다. 훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계입니다. 세상에 엮인 것이 많은 사람일수록 변하기 어려운 것처럼 객체가 실행되는 주변 환경에 강하게 결합될수록 변경하기 어려워지고 객체 간의 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범이라는 것을 기억해야 합니다. 여기서 주의해야할 점이 프로세스와 데이터를 하나의 모듈에 모아넣는 것만이 정답이 결코 아니라는 것입니다. 이는 객체 지향 설계로 나아가는 첫 걸음일 뿐이며 진정한 객체 지향 설계로 나아가는 길은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것입니다.

## References
> 조영호 님의 **오브젝트: 코드로 이해하는 객체지향 설계**