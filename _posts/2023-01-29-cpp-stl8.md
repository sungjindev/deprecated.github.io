---
title: 알아두면 쓸모있는 C++ STL 정리 8
categories: [Computer science, Algorithm]
tags: [알고리즘, 코딩 테스트, C++, STL]
---

알고리즘을 공부하면서 예전부터 정리해두고 싶었고 필자 본인이 다시 보기 위함이기도 한 유용한 C++ STL을 정리합니다.
알고리즘 공부를 계속하는 한 STL 정리에 관한 포스팅은 버전을 업데이트하며 주기적으로 업로드 할 예정입니다. 하지만, 주로 기록 목적의 포스팅이다보니 본문 내용에 일관성 없이 다양한 개념이 한번에 정리될 예정이므로 미리 참고 바랍니다.

## 구조체 생성자 정의
> 알고리즘 문제를 풀다보면 변수 여러개를 한 세트로 묶어 사용해야 하는 경우 구조체를 사용하는 경우가 많습니다. 이때 값 초기화를 조금 더 편하게 하기 위해 구조체 생성자를 정의해주면 좋습니다. 정의 방법은 아래 예제와 같습니다.
```cpp
struct position {
    int x,y,z;
    position(int X, int Y, int Z) : x(X), y(Y), z(Z) {};
};
```
위처럼 구조체명을 메소드 명으로 사용하고 적절한 이름의 파라미터를 설정하여 넣어줍니다. 이렇게 정의한 구조체 생성자를 통해 벡터에 바로 값을 전달하는 예제는 아래와 같습니다.
```cpp
v1.push_back(position(1,2,3));
```
이 외에도 아래와 같이 구조체 생성자도 다른 함수들과 같이 오버로딩을 사용할 수 있습니다. 오버로딩이란 동일한 클래스 혹은 구조체 내에서 동일한 이름의 메소드를 여러개 구현하는 것입니다. 이때 매개변수의 원형은 서로 달라야합니다. 아래 예제를 보면 쉽게 이해될 것입니다.
```cpp
struct position {
    int x,y,z;
    position() {x=100; y=200; z=300;};
    position(int X, int Y, int Z) : x(X), y(Y), z(Z) {};
}
``` 

## stable_sort()란?
> 알고리즘 정렬 문제를 풀면서 C++의 Algorithm 내 sort() 메소드를 정말 많이 사용하게 됩니다. 특히, 이 함수의 3번째 파리미터로 비교 연산을 메소드로 정의해서 많이 넘겨주게 되는데 x,y 값과 같은 2개의 변수 값을 pair로 묶어서 정렬한다고 했을 때 만약 x값이 동일한데 y값에 대한 정렬 우선 순위 기준을 비교 연산 메소드에서 정의해주지 않게 되면 어떤 순서로 정렬되는지 알고 있으십니까?  
정답은 우리가 흔히 쓰는 sort()를 사용하게 되면 명확한 기준 없이 어떤 원소가 먼저 나올지 알 수 없습니다. 그래서 이를 불안정 정렬이라고 부릅니다. 입력 받은 순서 그대로 출력이 되길 원한다면 아래와 같이 stable_sort()를 사용하면 됩니다. 이는 입력받은 순서 그대로 정렬되는 안정적인 정렬입니다. 사용법은 sort()와 동일합니다.
```cpp
stable_sort(v1.begin(), v1.end(), cmp);
```

## References
> https://taaewoo.tistory.com/7   
https://codingwell.tistory.com/44  