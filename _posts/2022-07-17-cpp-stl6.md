---
title: 알아두면 쓸모있는 C++ 정리 6
categories: [Computer science, Algorithm]
tags: [알고리즘, 코딩 테스트, C++, STL]
---

C++로 알고리즘을 공부하면서 예전부터 정리해두고 싶었고 필자 본인이 다시 보기 위함이기도 한 유용한 개념들을 정리합니다.
알고리즘 공부를 계속하는 한 이 포스팅은 버전을 업데이트하며 주기적으로 업로드할 예정입니다. 하지만, 주로 기록 목적의 포스팅이다보니 본문 내용에 일관성 없이 다양한 개념이 한번에 정리될 예정이므로 미리 참고 바랍니다. 

## next_permutation()이란?
> next_permutation()은 C++ algorithm 헤더 파일 내 순열 기능을 제공하는 메소드입니다. 기본적으로 next_permutation()은 파라미터로 iterator를 넘겨 받기 때문에 vector 뿐만 아니라 string 타입의 순열도 구할 수 있습니다. 이 메소드 내부 로직은 더 큰 순열로 재배열할 수 있을 때까지 계속 반복하여 구해내는 방식을 취하고 있어서 앞에 이미 큰 원소들이 배치되어 있으면 모든 순열의 경우의 수를 구할 수 없습니다. 따라서 본 함수를 사용하기 전에 오름차순으로 정렬 시켜놓은 뒤에 사용해야 모든 순열의 경우의 수를 구할 수 있습니다. 아래는 1,2,3,4의 숫자를 가지고 만들 수 있는 순열을 구하는 코드 예시입니다.  
  
```cpp
string s = "123";
do {
	cout << s << " "; //do while문을 반복할 때마다 s가 새로운 순열로 재배열됌
} while (next_permutation(s.begin(), s.end()));
```
위 코드를 작동시키면 아래와 같은 결과가 출력될 것입니다.  
  
```
123
132
213
231
312
321
```
위 결과를 보면 알 수 있듯이 처음에 인자로 넘겨준 string의 size에 따라 해당 size의 순열만이 결과로 출력되게 됩니다. 위 예시 같은 경우에는 string s가 size 3을 가지므로 3자리 수의 순열이 출력된 것입니다. 만약에 1자리 수부터 3자리 수까지의 모든 순열을 구하고 싶다면 아래와 같이 substr과 set(중복되는 부분 순열을 제거)을 활용하면 됩니다.  

```cpp
string s = "123";
set<int> set1;
string sub;
do {
  for(int i=1; i<=s.size(); i++) {
    sub = s.substr(0,i);
    set1.insert(stoi(sub));  //여기 substr()에 string의 이터레이터를 넣어주면 에러가 발생한다. 반드시 인덱스 번호를 넘겨줄 것
  }
} while (next_permutation(s.begin(), s.end()));
```
위에서 주의할 것은 substr()에는 반드시 index number만 들어갈 수 있다는 점입니다. string의 iterator가 들어갈 수 없음을 알아둡시다.

## next_permutation()을 활용한 조합
> 앞서 next_permutation()을 활용해서 순열을 구현할 수 있다고 배웠습니다. 지금부터는 이러한 next_permutation()을 활용해서 조합을 구현해볼 것입니다. 로직은 아래와 같습니다.
```
1. 구하고자 하는 조합 nCr에서 n의 개수에 맞게 시퀀스 컨테이너(벡터 혹은 배열 등)을 만듭니다.
2. 앞서 만든 컨테이너에 r의 개수만큼 1로 채워주고 n-r개 만큼 0을 채워줍니다.
3. next_permutation()을 사용하기 위해 위 컨테이너를 오름차순 정렬 해줍니다.
4. do while문을 사용하여 next_permutation()을 사용합니다.
5. do while문 내에서 순열을 조회하면서 원소로 1을 가지는 곳의 index들이 조합의 경우의 수들입니다. 
```

## static_cast<>란?
> static_cast<>란 형 변환을 도와주는 정적 캐스트 연산자입니다. 정적이라는 이름은 "컴파일 시간"에 형 변환이 올바르게 가능한지를 검사한다는 말입니다. 런타임 시간에 에러가 발생할 것 같으면 컴파일 시간에 미리 검사하여 에러를 발생시킵니다. 이와 다르게 dynamic_cast<>와 같은 동적 캐스트 연산자도 있는데 이는 런타임 시간에 형 변환에 대한 안정성 검사를 실시합니다. 가장 큰 차이점으로는 dynamic_cast<>는 기본 자료형 간의 형 변환은 지원하지 않습니다. 따라서 기본 자료형 간의 형 변환을 할 시에는 반드시 static_cast<>를 사용해줘야 합니다. 사용 예시는 아래와 같습니다.
```cpp
int a;
float b;
a = static_cast<int>(b);
```