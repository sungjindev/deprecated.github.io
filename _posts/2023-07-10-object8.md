---
title: 오브젝트(조영호 저)_ 의존성 관리하기
categories: [Computer science, Object Oriented Programming]
tags: [Object Oriented Programming, object, study, OOP, 객체 지향 프로그래밍, 객체, 스터디]
---

조영호 님의 **오브젝트: 코드로 이해하는 객체지향 설계**라는 책으로 객체 지향 프로그래밍과 관련된 스터디를 진행하며 공부한 내용을 정리하고 공유하고자 합니다. 각 포스팅은 챕터 별로 업로드될 예정이며, 모든 내용을 담기보다는 개인적으로 중요하다고 생각되는 내용 위주로 요약하여 작성할 예정입니다.

## 변경과 의존성
어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 됩니다. 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가집니다.
* 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
* 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
    
예를들어 PeriodCondition 클래스의 isSatisfiedBy 메서드는 Screening 인스턴스에게 getStartTime 메시지를 전송합니다. 실행 시점에 PeriodCondition의 인스턴스가 정상적으로 동작하기 위해서는 Screening의 인스턴스가 존재해야 합니다. 만약 Screening의 인스턴스가 존재하지 않거나 getStartTime 메시지를 이해할 수 없다면 PeriodCondition의 isSatisfiedBy 메서드는 예상했던 대로 동작하지 않을 것입니다.   
이처럼 어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재하다고 말합니다. 의존성은 방향성을 가지며 항상 단방향입니다. Screening이 변경될 때 PeriodCondition이 영향을 받게 되지만 그 역은 성립하지 않습니다.

## 의존성 전이
의존성은 전이될 수 있습니다. 의존성 전이(transitive dependency)가 의미하는 것은 PeriodCondition이 Screening에 의존할 경우 PeriodCondition은 Screening이 의존하는 대상에 대해서도 자동적으로 의존하게 된다는 것입니다. 다시 말해서 Screening이 가지고 있는 의존성이 Screening에 의존하고 있는 PeriodCondition으로도 전파된다는 것입니다.    
의존성은 함께 변경될 수 있는 가능성을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아닙니다. 의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라집니다. Screening이 의존하고 있는 어떤 요소의 구현이나 인터페이스가 변경되는 경우에 Screening이 내부 구현을 효과적으로 캡슐화하고 있다면 Screening에 의존하고 있는 PeriodCondition까지는 변경이 전파되지 않을 것입니다. 의존성 전이는 변경에 의해 영향이 널리 전파될 수 있다는 경고일 뿐입니다.   
의존성은 전이될 수 있기 때문에 의존성의 종류를 직접 의존성(direct dependency)과 간접 의존성(indirect dependency)으로 나누기도 합니다. 직접 의존성이란 말 그대로 한 요소가 다른 요소에 직접 의존하는 경우를 가리킵니다. PeriodCondition이 Screening에 의존하는 경우가 여기에 속하며, 이 경우 의존성은 PeriodCondition의 코드에 명시적으로 드러납니다. 간접 의존성이란 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가리킵니다. 이 경우 의존성은 PeriodCondition의 코드 안에 명시적으로 드러나지 않습니다.

## 런타임 의존성과 컴파일타임 의존성
의존성과 관련해서 다뤄야하는 또 다른 주제는 런타임 의존성(run-time dependency)과 컴파일타임 의존성(compile-time dependency)의 차이입니다. 먼저 여기서 사용하는 런타임과 컴파일타임의 의미를 이해할 필요가 있습니다.   
런타임은 간단합니다. 말 그대로 애플리케이션이 실행되는 시점을 가리킵니다. 컴파일타임은 약간 미묘합니다. 일반적으로 컴파일타임이란 작성된 코드를 컴파일하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체를 가리키기도 합니다. 컴파일타임 의존성이 바로 이런 경우에 해당합니다. 컴파일타임 의존성이라는 용어가 중요하게 생각하는 것은 시간이 아니라 우리가 작성한 코드의 구조이기 때문입니다. 또한 동적 타입 언어의 경우에는 컴파일타임이 존재하지 않기 때문에 컴파일타임 의존성이라는 용어를 실제로 컴파일이 수행되는 시점으로 이해하면 의미가 모호해질 수 있습니다. 따라서 어딘가에서 컴파일타임이라는 용어를 보게 된다면 그것이 정말 컴파일이 진행되는 시점을 가리키는 것인지 아니면 코드를 작성하는 시점을 가리키는 것인지를 파악하는 것이 중요합니다.   
객체지향 애플리케이션에서 런타임의 주인공은 객체입니다. 따라서 런타임 의존성이 다루는 주제는 객체 사이의 의존성입니다. 반면 코드 관점에서 주인공은 클래스입니다. 따라서 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성입니다.   
여기서 중요한 것은 런타임 의존성과 컴파일타임 의존성이 다를 수 있다는 것입니다. 사실 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 합니다.   
어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안됩니다. 실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 합니다. 클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자체가 없어집니다. 따라서 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해집니다.   
객체지향 프로그램의 실행 구조는 소스코드 구조와 일치하지 않는 경우가 종종 있습니다. 코드 구조는 컴파일 시점에 확정되는 것이고 이 구조에는 고정된 상속 클래스 관계들이 포함됩니다. 그러나 프로그램의 실행 시점 구조는 협력하는 객체에 따라서 달라질 수 있습니다. 즉, 두 구조는 전혀 다른 별개의 독립성을 갖습니다. 하나로부터 다른 하나를 이해하려는 것은 생태계의 동적인 성질을 식물과 동물과 같은 정적 분류 구조를 바탕으로 이해하려는 것과 똑같습니다. 컴파일 시점의 구조와 실행 시점 구조 사이에 차이가 있기 때문에 코드 자체가 시스템의 동작 방법을 모두 보여줄 수 없습니다. 시스템의 실행 시점 구조는 언어가 아닌 설계자가 만든 타입들 간의 관련성으로 만들어집니다. 그러므로 객체와 타입 간의 관계를 잘 정의해야 좋은 실행 구조를 만들어낼 수 있습니다.


## References
> 조영호 님의 **오브젝트: 코드로 이해하는 객체지향 설계**