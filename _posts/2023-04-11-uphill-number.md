---
title: 백준 11057번_ DP - 실버1 - 오르막 수
categories: [Computer science, Algorithm]
tags: [실버1, baekjoon online judge, dynamic programming, 11057번, 오르막 수, DP, 알고리즘, 코딩 테스트, 백준]
---

**!본 포스팅은 백준 코딩테스트 11057번 - [오르막 수](https://www.acmicpc.net/problem/11057) 풀이입니다.**

## 처음으로 맞춘 풀이
``` cpp
#include <iostream>
#define MOD 10007
using namespace std;

int main(void) {
    int n=0;
    int sum=0;
    int arr[1001][10] = {0,};
    
    for(int i=0; i<10; i++) {
        arr[1][i] = 1;
    }
    
    for(int i=0; i<1001; i++) {
        arr[i][0] = 1;
    }
    
    cin >> n;
    
    for(int i=2; i<=n; i++) {
        for(int j=1; j<10; j++) {
            arr[i][j] = (arr[i-1][j] + arr[i][j-1]) % MOD;
        }
    }
    
    for(int i=0; i<10; i++) {
        sum += arr[n][i]%MOD;
    }
    cout << sum%MOD;
    
    return 0;
}
```

이 문제는 앞선 쉬운 계단 수 문제에서 풀었던 방식과 동일한 유형의 Dynamic Programming 문제입니다. 해당 문제와 핵심 로직 자체가 굉장히 똑같습니다. DP의 핵심인 큰 문제를 작은 문제로 쪼개고 그 과정에서 발생하는 작은 결과 산출물들을 저장하는 방식으로 풀이하였습니다. 저는 Memorization을 위해 2차원 배열을 선언해줬습니다. 해당 배열의 행에는 N(숫자의 길이)를 매핑하고 열의 인덱스는 끝자리 수를 의미합니다. 즉 예를들어 5행 3열의 값은 N=5이면서 끝자리가 3인 수의 총 개수를 담고 있는 배열입니다. 이 방식을 활용해보면 **arr[i][j] = arr[i-1][j] + arr[i][j-1]** 이라는 식을 도출해낼 수 있습니다. 예를 들어서 arr[3][5] = arr[2][5] + arr[3][4]라고 하면 arr[3][5]는 총 3자리의 길이를 가지며 끝자리가 5인 _ _ 5와 같은 숫자입니다. 문제 조건에 따르면 _ _ 5 앞에는 _ 0, _ 1, _ 2, _ 3, _ 4, _ 5가 올 수 있습니다. 여기서 _ 5는 arr[2][5]이며, 나머지 _ 0, _ 1, _ 2, _ 3, _ 4들은 arr[3][4]에서 이미 구할 수 있습니다.   
또한 arr[1][?] 꼴의 원소는 1자리 수이므로 모두 1을 값을 가지게 되며, arr[?][0] 꼴의 원소는 끝자리가 0으로 끝나는 수들인데 0 앞에는 0밖에 올 수 없으므로 마찬가지로 가능한 경우의 수가 1가지입니다. 이렇게 배열을 초기화 시켜준 뒤 for loop를 통해 위에서 구한 식을 적용하면 경우의 수를 쉽게 구할 수 있습니다.   
그것보다 DP 문제나 구해야 하는 결과값이 매우 커지는 알고리즘 문제의 경우 엄청 큰수로 나눈 나머지를 구하는 문제가 많이 나오는데, 이때 모듈러 연산(나머지 연산)의 분배법칙에 대해 이해하고 있어야 합니다. 값이 커지는 즉시 모듈러 연산을 해줘야 오버플로우가 발생하지 않기 때문에 값이 커지는 그때그때마다 모듈러 연산의 분배법칙을 활용해 값의 크기를 줄여줘야 합니다. 

## 모듈러 연산(나머지 연산)의 분배법칙이란?
> 모듈러 연산이란 나머지 연산을 의미합니다. 앞서 말씀드린 것처럼 알고리즘 문제에서 값이 너무 커지면 오버플로우가 발생하게 되는데 이를 방지하기 위해 문제에서 임의의 큰 수로 나눈 나머지를 구하라는 문제가 많습니다. 이때 값이 매우 커지면 +,* 등의 연산을 할 때마다 즉시 나머지 연산을 해줘야하는데 이것은 모듈러 연산이 분배법칙이 적용되는지 유무에 따라 오류가 되기도하고 정답이 되기도 합니다. 모듈러 연산에서 말하는 분배법칙이란 다음과 같습니다. 
```
(A + B) % N = ((A % N) + (B % N)) % N
```
위 법칙이 성립함을 증명하는 과정은 아래와 같습니다.
```
A = q1 X N + r1 
B = q2 X N + r2
```
A,B를 N으로 나눴을 때 몫과 나머지를 각각 q1,r1과 q2,r2라고 합시다. 이를 첫번째 식에 적용하면
```
(q1 X N + r1 + q2 X N + r2)  
```
위 식을 아래와 같이 치환할 수 있습니다.
```
((q1+q2) X N + r1 + r2) % N
```
이때 모듈러는 나머지 연산이므로 결국 위 식의 나머지는 아래와 같습니다.
```
(r1+r2)%N
```
여기서 A,B를 N으로 나눈 나머지가 각각 r1,r2이므로 
``` 
r1 = A % N
r2 = B % N
```
이를 통해 아래 식이 성립함을 증명할 수 있습니다.
```
(A + B) % N = ((A % N) + (B % N)) % N
```
현재 위 증명 과정은 "+"로 묶여 있는 변수들간에 모듈러 분배법칙이 적용되는 것을 증명한 것인데, 이 외에도 "-"와 "*"에도 분배법칙이 적용 가능하지만 "/" 나누기 연산에는 성립하지 않습니다.
또한, "-" 연산의 경우 "-" 연산을 하다가 음수가 되지 않도록 경계하여 조정해줘야 하는데 이때 "-" 연산을 하다가 0에 가까워져 음수가 될 것 같으면 나누는 값을 한번 더해줘서 음수가 되지 않게 처리해주면 됩니다.  

## 다른 사람의 풀이1
``` cpp
#include <iostream>

using namespace std;
#define mod 10007

int dp[1001][10] = {
    0,
};
int main()
{
    int n;
    cin >> n;
    for (int i = 0; i < 10; i++)
        dp[1][i] = 1;

    for (int i = 2; i <= n; i++) {

        for (int j = 0; j < 10; j++) {
            if (j == 0) {
                dp[i][0] = 1;
                continue;
            }

            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]);
            dp[i][j] %= mod;
        }
    }

    int result = 0;
    for (int i = 0; i < 10; i++)
        result = (result + dp[n][i]);

    cout << result % mod;

    return 0;
}
```
다른 사람이 푼 풀이 역시 제 풀이와 로직이 모두 동일하여 부가적인 설명은 생략하도록 하겠습니다. 

## 최적화한 나의 풀이
최적화한 풀이가 다른 사람이 푼 풀이와 동일하여서 이하 설명은 생략하도록 하겠습니다.

## References
> https://ssinee.tistory.com/entry/%EB%B0%B1%EC%A4%80-11057%EB%B2%88-%EC%98%A4%EB%A5%B4%EB%A7%89-%EC%88%98-C