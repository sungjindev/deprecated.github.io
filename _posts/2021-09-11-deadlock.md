---
title: 기술 면접_ 데드락(Deadlock, 교착 상태)
categories: [Computer science, Technical interview]
tags: [CS, 기술 면접, 데드락, computer science, technical interview, deadlock]
---

!본 포스팅은 기술 면접을 대비하기 위한 포스팅입니다.

## 데드락(Deadlock, 교착 상태)
> **데드락(Deadlock, 교착 상태)이란 프로세스가 자원을 얻지 못하고 계속 기다리기만 하고 있는 상태로 교착 상태**라고 부르기도 합니다. 어떤 상황일 때 이런 교착 상태가 일어나는지 위 정의만 들으면 잘 이해가 안될 수 있으니 아래 그림을 보고 한번 이해해보겠습니다.
![deadlock](/assets/img/technical_interview/deadlock.png){: w="80%" h="80%" style="border:1px solid #eaeaea; border-radius: 7px; padding: 0px;"}
어느 날 t0라는 시각에 Process1과 Process2가 각각 모두 Resource1, Resource2를 모두 점유해서 사용해야된다고 가정해보겠습니다. 이런 상황에서 Process1은 Resource1을 점유했고, Process2는 Resource2를 점유한 상태입니다. 하지만 Process1 입장에서는 Resource2가 필요하고 Process2 입장에서는 ***Resource1이 추가적으로 필요한데 타 프로세스가 이미 점유하고 있는 상태라서 해당 Resource를 사용할 수 없는 상태로 무한 대기 상태에 빠지게 됩니다.**
바로 **이러한 상태를 교착 상태, Deadlock**이라고 부릅니다.

## 데드락(Deadlock)의 발생 조건 
> **데드락은 아래 조건 중에서 1개라도 만족할 시에 발생할 수 있습니다.**
1. **상호 배제(Mutual exclusion)**
* 한 번에 프로세스 하나만 해당 자원을 사용할 수 있음을 뜻 합니다.즉, 어떤 프로세스가 자원을 이미 사용중이라면 요청한 자원의 점유가 해제될 때까지 기다려야만 합니다.
2. **점유 대기(Hold and wait)**
*  자원을 하나 이상 점유하고 있으면서 다른 프로세스에 할당된 자원을 점유하기 위해 대기하고 있는 프로세스가 존재해야 합니다.
3. **비선점(No preemption)**
*  이미 할당되어 있는 자원을 강제로 뺏어올 수 없습니다.
4. **순환 대기(Circular wait)**
*  대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 합니다.

## 데드락(Deadlock) 해결법
> **데드락(Deadlock, 교착 상태)의 해결 방법을 아래와 같이 크게 3종류로 분류**할 수 있습니다.
1. **데드락이 발생하지 않도록 예방하기.(Prevention)**
2. **데드락 발생 가능성을 인정하면서 적절하게 회피하기.(Avoidance)**
3. **데드락 발생을 허용하지만 데드락을 탐지하여, 데드락으로부터 회복하기.(Detection & Recovery)**

## 데드락 예방(Prevention)
> 데드락의 예방 방법은 간단합니다. **앞서 배운 데드락의 발생 조건 중 하나라도 발생하지 않게 만드는 것이 예방법**입니다. **즉, 총 4가지의 발생 조건 각각을 방지할 수 있는 상황들이 예방법이라고 할 수 있어요.**
* **상호 배제를 금지** : 한 번에 여러 프로세스가 동시에 자원을 공유해서 사용할 수 있게 해주면 됩니다.
=> 하지만 공유 자원에 동시에 접근하게 되면 문제가 발생할 수 있으므로 동기화 처리를 해줘야 합니다.
* **점유 대기를 금지** : 프로세스에 필요한 자원을 요구할 때 모든 자원을 한꺼번에 요구하고 허용될 때까지 작업을 보류하면서 추후에 또다른 자원을 점유하기 위한 대기 상태를 만들지 않도록 할 수 있습니다.
* **비선점을 금지** : 이미 다른 프로세스에게 할당된 자원에 대한 선점권이 해당 프로세스에게 없다고 가정할 때, 우선순위가 높은 프로세스가 해당 자원을 선점할 수 있도록 해주면 됩니다.
* **순환 대기를 금지** : 자원을 순환 형태로 대기하지 않고 일방향적으로 자원에 대한 요구를 할 수 있도록 수정하면 됩니다.<br>

**이렇게 데드락을 예방할 수 있지만, 위와 같은 예방법을 사용하게 되면 시스템의 처리량이나 작업의 효율성을 떨어뜨리는 영향을 줄 수도 있습니다.** 그래서 데드락 예방법보다 조금 덜 제한적인 데드락 회피법(Avoidance)으로 데드락 예방법의 단점을 조금 해결할 수 있습니다.

## 데드락 회피(Avoidance)
> 데드락 회피법을 이해하기 위해서는 **아래 2가지 핵심 키워드**를 이해해야만 합니다.
1. **안정 상태(Safe state)**
* 시스템의 프로세스들이 요청하는 모든 자원을 데드락 없이 차례대로 모두에게 할당해줄 수 있다면 이러한 상태를 안정 상태(Safe state)에 놓여있다고 말합니다.
2. **안정 순서(Safe sequence)**
* 위처럼 안정 상태를 만들 수 있는 순서, 즉 특정한 순서로 프로세스들에게 자원을 할당하고 실행 및 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서가 있다면 이 순서를 안정 순서(Safe sequence)라고 부릅니다.

위에 나온 개념들과 반대 되는 개념으로, **불안정 상태**라는 것이 있습니다. 이름에서 알 수 있듯이 안정 상태가 아닌 상황을 말합니다. **즉, 데드락이 발생할 수 있는 상황을 뜻합니다. 데드락이 무조건 발생한다가 아니고 발생할 수 있다라는 것을 의미하기 때문에 굳이 따지자면 불안정 상태가 데드락의 집합보다 조금 더 큰 집합이라고 생각하시면 될 것 같습니다.(데드락 집합이 불안정 상태의 부분 집합이겠죠?)**
그말인 즉슨, **자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 해주면 데드락 회피가 가능**할 것입니다. **이러한 알고리즘으로 유명한 것이 은행원 알고리즘**입니다.

## 은행원 알고리즘(Banker's Algorithm)
> 위 알고리즘은 다익스트라가 제안한 알고리즘입니다. **어떤 자원을 할당하기 전에 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션해서 Safe state가 유지될 수 있는지 여부를 검사하는 알고리즘**입니다. **즉, 대기중인 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사**한다고 생각하면 될 것 같습니다. 
![banker](/assets/img/technical_interview/banker.png){: w="80%" h="80%" style="border:1px solid #eaeaea; border-radius: 7px; padding: 0px;"}

위 그림처럼 P0~P2의 프로세스가 있고, Max는 각 프로세스마다 최대 자원 요청량, Allocation은 각 프로세스 별로 현재 할당된 자원량, Need는 (Max값 - Allocation값)으로 남은 필요한 자원량이라고 정의하겠습니다.
그리고 시스템에는 총 12개의 자원을 가지고 있다고 가정해보겠습니다.
현재 각 프로세스에서 사용중인 자원량(Allocation)값을 모두 더해보면 5+2+2=9 입니다.
그러니까, 총 12개의 자원 중에서 9개의 자원을 사용하고 있으니까 3개의 자원이 남아있는 상태입니다.

이 상태에서 Safe sequence를 찾아보겠습니다. <P1, P0, P2> 순서로 자원이 할당될 때 Safe sequence를 만족하게 됩니다. 어렵지 않으니까 직접 해보는 것으로 하겠습니다.
이렇게 한다면 자원의 부족함 없이 Safe state를 유지할 수 있습니다.

**은행원 알고리즘을 간단하게 훑어보면서 누구에게 먼저 자원을 줄지도 굉장히 중요하고 자원을 줬다고 하더라도 어떤 시점에 자원을 다른 프로세스에게 주는 지도 굉장히 중요한 이슈가 됨을 알 수 있었을 겁니다. **

이렇게보면 은행원 알고리즘은 결점없이 완벽하기만 알고리즘 같긴 하지만 여기에 문제점이 있습니다. **미리 최대 자원 요규량을 알아야만 하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어서 제약 조건이 많습니다. 이러면서 자원 이용도 또한 하락할 수 있다는 단점이 존재하게 됩니다.**

## 데드락 탐지(Detection) 및 회복(Recovery)
> **데드락이 발생할 수 있음을 항상 열어두고 데드락이 발생했는지 안했는지 탐지해서, 발생했다면 회복하는 방법으로 데드락 이슈를 해결할 수도 있습니다.**
* **데드락 탐지(Detection)**
1. Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색합니다. 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악하는 방식입니다.
2. 이 외에도, 자원 할당 그래프를 통해 탐지하는 방법도 있습니다.<br>
* **회복(Recovery)**
1. **단순히 프로세스를 1개 이상 중단시켜서 데드락으로부터 회복**시킬 수 있습니다. 크게 여기에는 2가지 방법이 있을 수 있는데, **교착 상태에 빠진 모든 프로세스를 한번에 중단시키는 방법**이 있고, **프로세스를 하나씩 중단시켜 가면서 탐지 알고리즘을 통해서 데드락으로부터 회복되었는지 계속 탐색하는 방법**이 있습니다. **전자의 경우 계속해서 작업중이던 프로세스들이 모두 일시에 중단되기 때문에 작업중인 부분 결과가 폐기될 수 있다는 그런 부작용이 발생할 수 있고, 후자의 경우에는 매번 탐지 알고리즘을 수행해야 한다는 점에서 전자에 비해서 부담이 되는 작업**입니다.
2. **자원 선점을 통해서 데드락으로부터 회복**시켜줄 수도 있는데요, 이미 프로세스에 할당된 자원을 선점해서 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해주는 방법이 있습니다. **잠깐 자원을 빌려서 교착 상태를 해결할 때까지만 쓰고 다시 되돌려주는 방식**입니다.

## References
> https://chanhuiseok.github.io/posts/cs-2/