---
title: 기술 면접_ 페이지 교체 알고리즘
categories: [Computer science, Technical interview]
tags: [CS, 기술 면접, 페이지 교체, computer science, technical interview, page replacement]
---

!본 포스팅은 기술 면접을 대비하기 위한 포스팅입니다.

## 페이지 교체 알고리즘이란?
> 저번 가상 메모리 관련된 포스팅에서 페이지에 대한 개념을 배웠습니다. **페이지란 가상 메모리 시스템에서 데이터를 관리하는 기본 단위**입니다. **프로세스가 실행되면서 여러 페이지들을 참조하고자 요구하게 되는데, 그때 페이지가 실제 메모리에 올라가있지 않으면 페이지 폴트가 발생했다고 말하고 참조하고자 하는 페이지를 보조 기억장치에서 가져와야만 합니다. 
막상 보조 기억장치에서 우리가 찾는 페이지를 가져왔다고해도 메인 메모리가 페이지로 가득 차있으면 이미 쓰고 있는 페이지 중에 하나를 선택해서 제거해야하는데, 이때 앞으로 가장 덜 쓰일 페이지를 예측해서 제거한다면 더욱 효율적일 것입니다. 이런식으로 페이지 폴트가 최소화될 수 있도록 효율적인 알고리즘을 마련하는 것이 필요한데, 이와 관련된 알고리즘이 페이지 교체 알고리즘입니다.**
아래에서 그림과 함께 여러 알고리즘들을 공부할텐데, 아래 나오는 예시들은 모두 각 프로세스에 프레임을 3개로 주었다고 가정하겠습니다.
즉, 한 프로세스가 사용할 페이지를 3개까지 담을 수 있는 것이라고 생각하면 됩니다.

## FIFO(First In First Out)
> **가장 간단한 알고리즘으로, 자료구조를 공부한 사람이라면 기본적으로 알고있을 알고리즘**입니다.
**FIFO란, 가장 먼저 들어온 원소를 가장 먼저 내보내는 방식으로 한국말로하면 선입선출이라고도 합니다.
자료구조로는 queue로 구현할 수 있습니다.**
![fifo](/assets/img/technical_interview/fifo.png){: w="80%" h="80%" style="border:1px solid #eaeaea; border-radius: 7px; padding: 0px;"}
위 그림을 보면 7 0 1 ... 순으로 페이지가 들어온 것을 알 수 있습니다. 그래서 페이지 폴트가 발생해서 페이지 교체가 필요할 때 7 0 1이 순서대로 교체되는 것을 확인할 수 있습니다.
**이렇게 이해하기 쉽고 단순한만큼 효율성에 있어서 최적화된 알고리즘이라고 할 수는 없습니다. 
단적인 예로 위 그림에서 9번째 상황을 보면 2가 페이지 폴트가 발생해서 들어오는 상항인데 바로 앞 8번째 상황까지만 해도 2가 존재했지만 FIFO 알고리즘에 의해서 교체된 것을 확인할 수 있습니다. 
즉, 이렇게 활발하게 사용되고 있는 페이지일지라도 예외없이 자기 순서가 되면 가차없이 내보내집니다.**

## 최적의 페이지 교체 알고리즘이란?
> 그렇다면 **최적의 페이지 교체 알고리즘은 무엇일까요?** 우리는 FIFO 알고리즘을 예시로 보면서 대충 눈치를 챌 수 있었습니다. **바로 앞으로 쓰일 페이지는 메모리에 그대로 놔두고, 앞으로 안쓰일 페이지들을 순서대로 먼저 내보내면 될 것 입니다. 하지만 이 알고리즘은 이론상으로만 가능한 이야기입니다.
왜냐하면, 앞으로 어떤 페이지가 많이 쓰이고 앞으로 어떤 페이지는 덜 쓰일지는 미래에 갔다오지 않는 이상 예측으로만 가능한 이야기기 때문입니다.** 그래서 이 알고리즘은 연구 목적으로만 사용이 되고 이 알고리즘을 따라하는 **비슷한 알고리즘들이 존재**합니다. 아래에서 더욱 알아보도록 하겠습니다.

## LRU(Least-Recently-Used)
> **최적의 페이지 교체 알고리즘(Optimal page replacement algorithm)과 비슷한 성능을 내기 위해 개발된 알고리즘으로 LRU(Least-Recently-Used)란 알고리즘**이 있습니다. 최적의 알고리즘에서 얘기했듯이 우리는 가장 안쓰일 녀석들을 예측하는 것만이 최선의 방법이 될 수 있습니다.
**LRU는 최근에 가장 안쓰인 녀석들이 앞으로도 가장 안쓰일 것이라고 예측하는 방법입니다. 그래서 가장 오랜 기간동안 사용되지 않은 페이지를 교체 1순위로 삼는 것 입니다.**
![lru](/assets/img/technical_interview/lru.png){: w="80%" h="80%" style="border:1px solid #eaeaea; border-radius: 7px; padding: 0px;"} 
위 그림을 통해 이해해보면 좋을 것 같습니다.
**LRU 알고리즘은 성능이 어느정도 입증되어있는 상태라서 실제로 많은 운영체제에서 사용하고 있는 알고리즘이고 좋은 알고리즘이라고 평가**받고 있습니다.

## 계수-기반(Counting-Based) 페이지 교체
> **LRU 알고리즘을 기반으로 하지만 페이지가 참조될 때마다 해당 페이지가 몇번이나 참조되었는 지를 확인하기 위해서 지속적으로 Counting을 하고 그 값을 기반으로 페이지 교체 우선 순위를 결정하는 알고리즘**이 있습니다. **이를 계수-기반(Counting-Based) 페이지 교체 알고리즘**이라고 하는데, 
Counting-Based 알고리즘의 대표적인 예시 LFU(Least-Frequently-Used)와 
MFU(Most-Frequently-Used)에 대해 알아보겠습니다.

## LFU(Least-Frequently-Used)
> **LFU는 Couting-Based 페이지 교체 알고리즘의 일종**입니다. **기본적으로 LRU(Least-Recently-Used)알고리즘을 기반으로 하고 있습니다. 참조 횟수를 계속해서 세면서 그때 그때 참조 횟수가 가장 작은 녀석을 내보내는 알고리즘입니다.**
![lfu1](/assets/img/technical_interview/lfu1.png){: w="80%" h="80%" style="border:1px solid #eaeaea; border-radius: 7px; padding: 0px;"}
**이 LFU에는 치명적인 단점이 하나 존재하는데, 특정 페이지를 초반에만 많이 참조하고 나중에 안쓰는 경우에 비효율적일 수 있습니다. 바로 아래와 같은 상황처럼 말입니다.**
![lfu2](/assets/img/technical_interview/lfu2.png){: w="80%" h="80%" style="border:1px solid #eaeaea; border-radius: 7px; padding: 0px;"}

## MFU(Most-Frequently-Used)
> **MFU 역시 Counting-Based 알고리즘의 일종인데, LFU와 반대 개념**이라고 생각하시면 됩니다. **참조 횟수가 가장 많은 페이지를 1순위 교체 대상으로 삼는 알고리즘**입니다. **참조 횟수가 적은 페이지들은 최근에 사용된 페이지이기 때문에 앞으로도 사용될 가능성이 높다고 판단**하는 것 입니다.
![mfu](/assets/img/technical_interview/mfu.png){: w="80%" h="80%" style="border:1px solid #eaeaea; border-radius: 7px; padding: 0px;"}

**이렇게 Counting-Based 알고리즘의 예시 2개로 LFU, MFU까지 다뤄봤는데, 사실 위 2개의 알고리즘은 실제로 잘 쓰이지 않습니다. 왜냐하면 구현하기가 상당히 까다롭고 LRU에 비해서 최적의 페이지 교체 알고리즘을 유사하게 구현해내지 못하기 때문입니다. 그래서 일반적으로는 LRU 알고리즘을 가장 많이 쓴다고 알고 계시면 될 것 같습니다.**

## References
> https://medium.com/pocs/%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-page-replacement-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-650d58ae266b



