---
title: 오브젝트(조영호 저)_ 객체 분해
categories: [Computer science, Object Oriented Programming]
tags: [Object Oriented Programming, object, study, OOP, 객체 지향 프로그래밍, 객체, 스터디]
---

조영호 님의 **오브젝트: 코드로 이해하는 객체지향 설계**라는 책으로 객체 지향 프로그래밍과 관련된 스터디를 진행하며 공부한 내용을 정리하고 공유하고자 합니다. 각 포스팅은 챕터 별로 업로드될 예정이며, 모든 내용을 담기보다는 개인적으로 중요하다고 생각되는 내용 위주로 요약하여 작성할 예정입니다.

## 객체 분해
사람의 기억은 단기 기억(short-term memory)과 장기 기억(long-term memory)으로 분류할 수 있습니다. 장기 기억은 매우 큰 저장 용량을 가지고 있으며 그 용량은 거의 무한대에 이르는 것으로 알려져 있습니다. 일반적으로 장기 기억 안에 보관돼 있는 지식은 직접 접근하는 것이 불가능하고 먼저 단기 기억 영역으로 옮긴 후에 처리해야 합니다.   
이에 비해 단기 기억은 보관돼 있는 지식에 직접 접근할 수 있지만 정보를 보관할 수 있는 속도와 공간적인 측면 모두에서 제약을 받습니다. 조지 밀러의 이론에 따르면 사람이 동시에 단기 기억 안에 저장할 수 있는 정보의 개수는 5개에서 많아 봐야 9개 정도를 넘지 못한다고 합니다. 또한 허버트 사이먼에 따르면 사람이 새로운 정보를 받아들이는 데 5초 정도의 시간이 소요된다고 합니다. 컴퓨터 프로그램을 작성할 때는 시간과 공간의 트레이드오프를 통해 효율을 향상시킬 수 있지만 사람의 경우에는 트레이드오프의 여지가 전혀 없습니다. 사람의 단기 기억에 있어 시간과 공간의 두 측면 모두가 병목지점으로 작용하는 것입니다.   
여기서 핵심은 실제로 문제를 해결하기 위해 사용하는 저장소는 장기 기억이 아니라 단기 기억이라는 점입니다. 문제를 해결하기 위해서는 필요한 정보들을 먼저 단기 기억 안으로 불러들여야 합니다. 그러나 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 급격하게 떨어지고 맙니다. 이런 현상을 인지 과부하(cognitive overload)라고 부릅니다.   
인지 과부화를 방지하는 가장 좋은 방법은 단기 기억 안에 보관할 정보의 양을 조절하는 것입니다. 한 번에 다뤄야 하는 정보의 수를 줄이기 위해 본질적인 정보만 남기고 불필요한 세부 사항을 걸러내면 문제를 단순화할 수 있을 것입니다. 이처럼 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업을 추상화라고 부릅니다.   
가장 일반적인 추상화 방법은 한 번에 다뤄야하는 문제의 크기를 줄이는 것입니다. 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 분해(decomposition)라고 부릅니다.    
분해의 목적은 큰 문제를 인지 과부하의 부담 없이 단기 기억 안에서 한 번에 처리할 수 있는 규모의 문제로 나누는 것입니다. 여기서 한 가지 주목할 점은 조지 밀러의 매직 넘버 7이 정보의 가장 작은 단위로서의 개별 항목을 의미하는 것이 아니라 하나의 단위로 취급될 수 있는 논리적인 청크(chunk)를 의미한다는 점입니다. 청크는 더 작은 청크를 포함할 수 있으며 연속적으로 분해 가능합니다. 예를 들어, 임의로 조합된 11자리 정수 8개를 한꺼번에 기억하는 것은 힘들지만 11자리 정수를 전화번호라는 개념적 청크로 묶으면 8명에 대한 전화번호(따라서 8 * 11개의 정수)를 기억할 수 있도록 인지 능력을 향상시킬 수 있는 것입니다.   
한 번에 단기 기억에 담을 수 있는 추상화의 수에는 한계가 있지만 추상화를 더 큰 규모의 추상화로 압축시킴으로써 단기 기억의 한계를 초월할 수 있습니다. 따라서 추상화와 분해는 인간이 세계를 인식하고 반응하기 위해 사용하는 가장 기본적인 사고 도구라고 할 수 있습니다.

## 프로시저 추상화와 데이터 추상화
프로그래밍 언어의 발전은 좀 더 효과적인 추상화를 이용해 복잡성을 극복하려는 개발자들의 노력에서 출발했습니다. 어셈블리어는 숫자로 뒤범벅이 된 기계어에 인간이 이해할 수 있는 상징을 부여하려는 노력의 결과입니다. 고수준 언어는 기계적인 사고를 강요하는 낮은 수준의 명령어들을 탈피해서 인간의 눈높이에 맞는 기계 독립적이고 의미 있는 추상화를 제공하려는 시도의 결과였습니다.   
현대적인 프로그래밍 언어를 특징 짓는 중요한 두 가지 추상화 메커니즘은 프로시저 추상화(procedure abstraction)와 데이터 추상화(data abstraction)입니다. 프로시저 추상화는 소프트웨어가 무엇을 해야 하는지를 추상화합니다. 데이터 추상화는 소프트웨어가 무엇을 알아야 하는지를 추상화합니다. 소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작합니다. 현대의 설계 방법에 중요한 영향을 끼치는 프로그래밍 패러다임들은 프로시저 추상화나 데이터 추상화를 중심으로 시스템의 분해 방법을 설명합니다.   
시스템을 분해하는 방법을 결정하려면 먼저 프로시저 추상화를 중심으로 할 것인지, 데이터 추상화를 중심으로 할 것인지를 결정해야 합니다. 프로시저 추상화를 중심으로 시스템을 분해하기로 결정했다면 기능 분해(functional decomposition)의 길로 들어서는 것입니다. 기능 분해는 알고리즘 분해(algorithmic decomposition)라고 부르기도 합니다. 데이터 추상화를 중심으로 시스템을 분해하기로 결정했다면 다시 두 가지 중 하나를 선택해야 합니다. 하나는 데이터를 중심으로 타입을 추상화(type abstraction)하는 것이고 다른 하나는 데이터를 중심으로 프로시저를 추상화(procedure abstraction)하는 것입니다. 전자를 추상 데이터 타입(Abstract Data Type)이라고 부르고 후자를 객체지향(Object-Oriented)이라고 부릅니다.   
프로그래밍 언어의 관점에서 객체지향이란 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용해 시스템을 분해하는 방법입니다. 그리고 이런 객체를 구현하기 위해 대부분의 객체지향 언어는 클래스라는 도구를 제공합니다. 따라서 프로그래밍 언어적인 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것입니다.

## 프로시저 추상화와 기능 분해
기능과 데이터의 첫 번째 전쟁에서 신은 기능의 손을 들어주었습니다. 기능은 오래동안 시스템을 분해하기 위한 기준으로 사용됐으며, 이 같은 시스템 분해 방식을 알고리즘 분해 또는 기능 분해라고 부릅니다. 기능 분해의 관점에서 추상화의 단위는 프로시저이며 시스템은 프로시저를 단위로 분해됩니다.   
프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법입니다. 프로시저를 추상화라고 부르는 이유는 내부의 상세한 구현 내용을 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기 때문입니다. 따라서 프로시저는 잠재적으로 정보은닉(information hiding)의 가능성을 제시하지만 뒤에서 살펴보는 것처럼 프로시저만으로 효과적인 정보은닉 체계를 구축하는 데는 한계가 있습니다.   
전통적인 기능 분해 방법은 하향식 접근법(Top-Down Approach)을 따릅니다. 하향식 접근법이란 시스템을 구성하는 가장 최상위(topmost) 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말합니다. 분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 계속됩니다. 각 세분화 단계는 바로 위 단계보다 더 구체적이어야 합니다. 다시 말해 정제된 기능은 자신의 바로 상위 기능보다 덜 추상적이어야 합니다. 상위 기능은 하나 이상의 더 간단하고 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해됩니다.


## References
> 조영호 님의 **오브젝트: 코드로 이해하는 객체지향 설계**