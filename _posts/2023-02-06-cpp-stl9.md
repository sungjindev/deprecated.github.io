---
title: 알아두면 쓸모있는 C++ STL 정리 9
categories: [Computer science, Algorithm]
tags: [알고리즘, 코딩 테스트, C++, STL]
---

알고리즘을 공부하면서 예전부터 정리해두고 싶었고 필자 본인이 다시 보기 위함이기도 한 유용한 C++ STL을 정리합니다.
알고리즘 공부를 계속하는 한 STL 정리에 관한 포스팅은 버전을 업데이트하며 주기적으로 업로드 할 예정입니다. 하지만, 주로 기록 목적의 포스팅이다보니 본문 내용에 일관성 없이 다양한 개념이 한번에 정리될 예정이므로 미리 참고 바랍니다.

## list란?
> 알고리즘 문제를 풀면서 시퀀스 컨테이너 상에서 데이터의 삽입 삭제가 빈번하게 일어나는 경우 보통 중간 위치에서의 데이터 삽입, 삭제가 O(1) 밖에 안걸리는 연결 리스트 자료구조를 사용하게 됩니다. 벡터나 배열과 같은 경우에는 중간 위치에서의 데이터 삽입, 삭제는 다른 원소들을 끌거나 밀어주는 연산이 필요하여 시간 복잡도가 O(n)이나 걸리기 때문입니다. 이렇게 중간에서의 데이터 삽입, 삭제의 이점을 가지는 연결 리스트는 조회에 있어서는 O(1)이 걸리는 벡터나 배열과 달리 보통 head라고 부르는 항상 첫 번째 원소부터 탐색을 시작해야 되기 때문에 O(n)이 걸린다는 단점이 있습니다. 이러한 연결 리스트에는 각 노드 별로 데이터와 다음 노드를 가리키는 포인터가 들어있는 단일 연결리스트와 각 노드 별로 데이터와 이전과 다음 노드를 모두 가리키는 두개의 포인터를 가지고 있는 이중 연결 리스트 등이 있습니다. 그 중에서도 C++의 STL에 존재하는 **list**는 내부적으로 이중 연결 리스트로 구현되어 있습니다. list는 <list>라는 헤더 파일 내에 존재합니다. C++에서 list의 선언은 아래와 같이 할 수 있습니다.
```cpp
list <int> list1;
list <int> list2(5); //5개의 0으로 초기화하며 선언
list <int> list3(4,3); //4개의 3으로 초기화하며 선언
list <int> list4 = {1, 2} // 1,2를 초기값으로 선언 
list <char> list5(str1.begin(), str1.end()); //이터레이터를 활용하여 string 데이터 전체 복사
```
지금부터는 다양한 list의 멤버 함수에 대해 알아보겠습니다.
1. list1.assign(2,4); //2개의 4로 초기화된 원소를 할당
2. list1.front(); //가장 첫 번째 원소를 리턴
3. list1.back(); //가장 마지막 원소를 리턴
4. list1.begin(); //가장 첫 번째 원소를 가리키는 이터레이터 리턴
5. list1.end(); //가장 마지막 원소를 가리키는 이터레이터 리턴
6. list1.push_back(k); //가장 마지막 원소로 k를 삽입
7. list1.push_front(k); //가장 첫 번째 원소로 k를 삽입
8. list1.pop_back(); //가장 마지막 원소를 제거
9. list1.pop_front(); //가장 첫 번째 원소를 제거
10. list1.insert(iter, k); //iter 위치에 k를 삽입합니다. 만약 iter를 변수로 선언해서 계속 재활용하고 있다면 삽입했다고 해서 iter 값이 바뀌지 않으므로 이것에 주의해야 합니다. 삽입한 원소를 가리키는 이터레이터를 반환합니다.  
11. list1.erase(iter); //iter가 가리키는 곳에 위치한 원소를 삭제합니다. 마찬가지로 iter를 계속 재활용하고 있다면 삭제했다고 해서 iter 값이 바뀌지 않으므로 주의해야합니다. 삭제된 노드를 가리키고 있어서 segmentation fault가 발생할 수 있습니다. 삭제한 원소의 다음 원소를 가리키는 이터레이터를 반환하기 때문이 이 리턴값을 받아 fault를 해결할 수 있습니다.
12. list1.size(); //list에 들어있는 원소의 개수를 리턴합니다.
13. list1.remove(k); //k라는 값을 가지는 모든 원소를 제거합니다.
14. list1.remove(Predicate); //단항 조건자 Predicate에 해당하는 모든 원소를 제거합니다. 단항 조건자라고 하면 Sort() 알고리즘을 활용할 때 직접 만들어 사용하는 compare 비교 함수를 생각하면 됩니다.
15. list1.reverse(); //원소들의 순서를 뒤집습니다.
16. list1.swap(list2); //list1과 list2의 내용을 바꿉니다.
17. list2.splice(iter2, list1); // list2의 iter2가 가리키는 위치에 list1의 모든 원소를 잘라 붙여넣습니다.
18. list1.unique(); //인접한(양 옆의) 원소가 같으면 유일하게 만듭니다. (하나만 남겨두고 인접한 원소 중 같은 원소는 모두 삭제)
19. list2.merge(list1); //list1을 list2로 합병 정렬합니다. 기본값은 오름차순이지만 두번째 파라미터로 이항 조건자가 올 수 있습니다. merge 함수를 올바르게 동작시키기 위해서는 list1, list2가 모두 정렬된 상태여야 합니다.

## 최대 공약수(GCD)와 최소 공배수(LCM)란?
> 최대 공약수와 최소 공배수를 구하는 알고리즘으로 유클리드 호제법을 많이들 이용합니다. 최소 공배수는 두 수를 곱한 값을 두 수의 최대 공약수로 나눠주기만 하면 구할 수 있어서 최대 공약수를 구하는 알고리즘만 알고 있으면 두 개 모두 쉽게 구할 수 있습니다. 두 수 a,b(a>b라는 가정이 필요)에 대해서 최대 공약수를 구하는 알고리즘은 아래와 같습니다.
```cpp
a > b ? gcd(a,b) : gcd(b,a); //a>b라는 가정이 필요합니다.
int gcd(int a, int b) {
    int r=0;
    while(b != 0) {
        r = a%b;
        a = b;
        b = r;
    }
    return a;
}
```
최소 공배수를 구하는 방법은 아래와 같습니다.
```cpp
lcm = (a*b) / gcd(a,b);
```

## string 내 size(), length() 사용 시 오버플로우
> string을 활용한 문제를 풀다보면 자연스럽게 str.size()와 str.length()등을 활용하여 조건으로 이용하는 경우가 많습니다. 이때 아래와 같이 사용한다고 가정하고 문자열의 길이가 1이라면 오버플로우가 발생합니다.
```cpp
if(i < str.size()-2) {
    i++;
}
``` 
그 이유는 size()와 length()의 반환값에 있습니다. 이 메소드들의 반환값은 size_t라는 자료형으로 이것은 unsigned int와 거의 유사합니다. 따라서 unsigned 자료형이 음수가 될 수 없으므로 오버플로우가 발생하는 것입니다. 이를 해결하기 위해서는 아래와 같이 형 변환을 해주어 사용하면 의도한대로 정상 작동합니다.
```cpp
if(i < int(str.size())-2) {
    i++;
}
```

## 에라토스테네스의 체
> 소수는 1과 자기 자신으로 밖에 나누어 떨어지지 않는 수를 의미합니다. 참고적으로 말하자면 1은 소수가 아닙니다. 따라서 2,3,5,7 등과 같은 수가 소수입니다. 알고리즘 문제를 풀면서 소수를 찾아야 하는 경우가 종종 있는데 이때 물론 반복문과 소수의 정의를 이용해서 나누어 떨어지는지 아닌지를 모두 테스트해봐도 되지만 이렇게 할 경우에는 시간이 너무 오래걸려서 시간 초과에 걸리기 마련입니다. 이때 소수를 더욱 빠르게 찾기 위해 저희가 활용할 수 있는 것이 **에라토스테네스의 체**입니다. 체를 통해 하나씩 걸러낸다는 의미로 1부터 100까지의 소수를 구해야한다고 하면, 2의배수 부터 시작해서 10의배수까지 모두 탐색하여 배수가 되는 것들을 지우고 남은 나머지들이 소수가 되는 원리입니다. 이때 왜 10의 배수까지만 거르냐고 물어보신다면 100이라는 수를 두 수의 곱으로 나타냈을 때 두 수 중 작은 값이 아무리 커봤자 sqrt(100)=10이 됩니다. 즉, 아무리 커봤자 10 이내로 배수 판정이 모두 되어 걸러지기 때문에 10까지만 탐색을 하는 것입니다. 이를 일반화 시켜서 나타내면 2의 배수부터 시작해서 sqrt(num)보다 작거나 같은 수의 배수까지만 걸러내면 나머지는 모두 소수가 되는 것입니다. 이를 코드로 나타내면 아래와 같습니다.   

```cpp
#include<iostream>
#include<cmath>
using namespace std;

int main(void)
{
    int arr[1000001] = {0,};

    arr[0] = 1;
    arr[1] = 1;
    
    for(int i=2; i<=sqrt(1000000); i++) {
        if(arr[i])  //이 if문이 반드시 들어가야 시간 절약이 됩니다. 왜냐하면 i가 2일때 4,6,8 등 2의 배수를 제거하는데 i가 4,6,8이 되었을 때 어차피 이미 소수가 아님을 알고 있으므로 밑에 루프를 돌 필요가 없습니다.
            continue;
        for(int j=2*i; j<=1000000; j+=i) {
            arr[j] = 1;
        }
    }
    
    for(int z=0; z<=1000000; z++) {
        if(arr[z] == 0)
            cout << z << " ";
    }
}
```

## References
> https://karen0117.tistory.com/84    
https://blockdmask.tistory.com/76  
https://cocoon1787.tistory.com/88